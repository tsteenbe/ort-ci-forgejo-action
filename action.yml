---
# Copyright (C) 2022 The ORT Project Authors
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
# License-Filename: LICENSE

name: "Forgejo Action for ORT"
description: "A Forgejo Action workflow to run ORT."
author: "The ORT Project Authors"

env:
  ORT_VERSION_DEFAULT: "72.0.0"

inputs:
  vcs-type:
    default: "git"
    description: |
      Type of version control system.
      Accepted values are 'git', 'git-repo', 'mercurial' or 'subversion'.
    required: false
  vcs-url:
    default: ""
    description: |
      Repository or clone URL of project to scan.
    required: false
  vcs-revision:
    default: ""
    description: |
      SHA1 or tag to scan (do not use branch names as they can move).
      If vcs-type is 'git-repo', SHA1 must be unabbreviated.
      Tag names must be prefixed with 'refs/tags/'.
    required: false
  vcs-path:
    default: ""
    description: |
      Leave this field empty unless one of the following special cases applies:
      1) project vcs-type is git-repo - specify path to repo manifest file
      (e.g. sdk.xml, note vcs-url must point to a manifest repository)
      2) you require sparse checkout - specify repository sub-path to download and scan
      (e.g. projects/gradle/, note sparse checkout is possible only for vcs-type git, mercurial or subversion)
  advisors:
    default: "OSV"
    description: |
      Comma-separated list of security vulnerability advisors to use.
    required: false
  allow-dynamic-versions:
    default: "false"
    description: |
      Set to 'true' only if dynamic dependency versions are allowed (note version ranges specified for dependencies may cause unstable results).
      This field applies only to package managers that support lock files, e.g. NPM.
    required: false
  db-url:
    default: ""
    description: |
      URL of the PostgreSQL database used for caching scan-results and storing file archives.
    required: false
  db-username:
    default: ""
    description: |
      Username for the PostgreSQL database used for caching scan-results and storing file archives.
    required: false
  db-password:
    default: ""
    description: |
      Password for the PostgreSQL database used for caching scan-results and storing file archives.
    required: false
  dist-archive-url:
    default: ""
    description: |
      The ORT distribution archive to use.
      If empty, then github.com/oss-review-toolkit/ort/releases/download/72.0.0/ort-72.0.0.tgz is used.
    required: false
  docker-cli-args:
    default: ""
    description: |
      List of arguments to pass to Docker CLI.
    required: false
  fail-on:
    default: ""
    description: |
      Comma-separated list of ORT results that if exceeding their severity threshold will fail the action.
      Accepted values are '', 'issues', 'violations' or 'issues,violations'.
      If empty, then exceeding severity threshold will not fail the action.
    required: false
  http-file-server-url:
    default: ""
    description: |
      URL of the HTTP file server used for caching scan-results and storing file archives.
    required: false
  http-file-server-username:
    default: ""
    description: |
      Username for HTTP file server used for caching scan-results and storing file archives.
    required: false
  http-file-server-password:
    default: ""
    description: |
      Password for HTTP file server used for caching scan-results and storing file archives.
    required: false
  http-file-server-token:
    default: ""
    description: |
      API token for HTTP file server used for caching scan-results and storing file archives.
    required: false
  image:
    default: "ghcr.io/oss-review-toolkit/ort:latest"
    description: |
      URL for ORT Docker image to use.
    required: false
  log-level:
    default: "warn"
    description: |
      Set value to 'debug' to see additional debug output to help tracking down errors.
    required: false
  mode:
    default: "da"
    description: |
      Run the action using Docker-in-Docker (dnd) with the specified ORT Docker image in 'image',
      or natively using the ORT distribution archive (da).
      Accepted values: 'dnd', 'docker-in-docker', 'da', or 'dist-archive'.
  ort-cli-args:
    default: "-P ort.forceOverwrite=true --stacktrace"
    description: |
      List of arguments to pass to ORT CLI, applies to all commands.
    required: false
  ort-cli-analyze-args:
    default: ""
    description: |
      List of arguments to pass to ORT Analyzer CLI.
    required: false
  ort-cli-scan-args:
    default: ""
    description: |
      List of arguments to pass to ORT Scanner CLI.
    required: false
  ort-cli-evaluate-args:
    default: ""
    description: |
      List of arguments to pass to ORT Evaluator CLI.
    required: false
  ort-cli-advise-args:
    default: ""
    description: |
      List of arguments to pass to ORT Advisor CLI.
    required: false
  ort-cli-report-args:
    default: "-O CycloneDX=output.file.formats=json,xml -O SpdxDocument=output.file.formats=json,yaml"
    description: |
      List of arguments to pass to ORT Reporter CLI.
    required: false
  ort-config-path:
    default: ""
    description: |
      Path to ORT configuration directory within the user home directory.
    required: false
  ort-home-path:
    default: ".ort"
    description: |
      Path to ORT 'home' or 'data' directory within the user home directory.
    required: false
  ort-config-repository:
    default: "https://github.com/oss-review-toolkit/ort-config.git"
    description: |
      URL to ORT configuration repository to use.
    required: false
  ort-config-revision:
    default: "main"
    description: |
      The Git revision or branch of the ORT configuration repository to use.
    required: false
  ort-yml-path:
    default: ""
    description: |
      Path to file containing the repository configuration.
      If set, the '.ort.yml' file from the repository is ignored.
    required: false
  orth-dist-archive-url:
    default: ""
    description: |
      The ORT helper distribution archive to use.
      If empty, then github.com/oss-review-toolkit/ort/releases/download/72.0.0/orth-72.0.0.tgz is used.
    required: false
  project-path:
    default: "${{ forgejo.workspace }}"
    description: |
      Path within $FORGEJO_WORKSPACE to be analyzed/scanned with ORT.
      If empty, $FORGEJO_WORKSPACE directory is scanned.
    required: false
  report-formats:
    default: "CycloneDx,SpdxDocument,WebApp"
    description: |
      Comma-separated list of ORT reporters to run.
    required: false
  run:
    default: >
      init,
      setup-python,
      setup-python-setuptools,
      setup-python-inspector,
      setup-java,
      setup-ort,
      cache-dependencies,
      config-git-use-https,
      labels,
      analyzer,
      evaluator,
      advisor,
      reporter,
      upload-results
    description: |
      Comma-separated list of optional workflow steps to run.
    required: false
  sw-name:
    default: ""
    description: |
      Name of project, product or component to be scanned.
      By default the name of the repository is used as shown in its clone URL.
    required: false
  sw-version:
    default: ""
    description: |
      Project version number or release name (use the version from package metadata, not VCS revision).
      By default, the Git short SHA is used.
    required: false

outputs:
  advisor-exit-code:
    description: The exit code of the ORT Advisor CLI command.
    value: "${{ steps.ort-da-advisor.outputs.exit-code || steps.ort-dnd-advisor.outputs.exit-code }}"
  dist-archive-url:
    description: The ORT distribution archive used.
    value: "${{ steps.ort-da-setup-ort.outputs.dist-archive-url || inputs.dist-archive-url }}"
  evaluator-exit-code:
    description: The exit code of the ORT Evaluator CLI command.
    value: "${{ steps.ort-da-evaluator.outputs.exit-code || steps.ort-dnd-evaluator.outputs.exit-code }}"
  ort-config-path:
    description: The path to the ORT configuration directory that was used.
    value: "${{ steps.ort-init.outputs.ort-config-path }}"
  ort-config-vcs-revision:
    description: The Git revision or branch of the ORT configuration repository that was used.
    value: " ${{ steps.ort-config-via-git.outputs.ort-config-vcs-revision || steps.ort-config-via-curl.outputs.ort-config-vcs-revision || inputs.ort-config-revision }}"
  ort-config-vcs-url:
    description: URL to ORT configuration repository that was used.
    value: "${{ steps.ort-config-via-git.outputs.ort-config-vcs-url || steps.ort-config-via-curl.outputs.ort-config-vcs-url || inputs.ort-config-repository }}"
  ort-cli-advise-args:
    description: Arguments passed to the ORT Advisor.
    value: "${{ inputs.ort-cli-advise-args }}"
  ort-cli-analyze-args:
    description: Arguments passed to the ORT Analyzer.
    value: "${{ steps.ort-labels.outputs.ort-cli-analyze-args || inputs.ort-cli-analyze-args }}"
  ort-cli-evaluate-args:
    description: Arguments passed to the ORT Evaluator.
    value: "${{ steps.ort-labels.outputs.ort-cli-evaluate-args || inputs.ort-cli-evaluate-args }}"
  ort-cli-report-args:
    description: Arguments passed to the ORT Reporter.
    value: "${{ steps.ort-labels.outputs.ort-cli-report-args || inputs.ort-cli-report-args }}"
  ort-cli-scan-args:
    description: Arguments passed to the ORT Scanner.
    value: "${{ inputs.ort-cli-scan-args }}"
  ort-version:
    description: The version of the software analyzed with ORT.
    value: "${{ steps.ort-da-setup-ort.outputs.ort-version }}"
  orth-dist-archive-url:
    description: The ORT helper distribution archive used.
    value: "${{ steps.ort-da-setup-ort.outputs.orth-dist-archive-url || inputs.orth-dist-archive-url }}"
  results-advisor-path:
    description: Path to the advisor result file.
    value: "${{ steps.ort-init.outputs.results-advisor-path }}"
  results-analyzer-path:
    description: Path to the advisor result file.
    value: "${{ steps.ort-init.outputs.results-analyzer-path }}"
  results-evaluator-path:
    description: Path to the evaluator result file.
    value: "${{ steps.ort-init.outputs.results-evaluator-path }}"
  results-evaluated-model-path:
    description: Path to the evaluated model result file.
    value: "${{ steps.ort-init.outputs.results-evaluated-model-path }}"
  results-path:
    description: Path to the result directory.
    value: "${{ steps.ort-init.outputs.results-path }}"
  results-report-html-path:
    description: Path to the static HTML report file.
    value: "${{ steps.ort-init.outputs.results-report-html-path }}"
  results-report-web-app-path:
    description: Path to the Web App report file.
    value: "${{ steps.ort-init.outputs.results-report-web-app-path }}"
  results-sbom-cyclonedx-xml-path:
    description: Path to the CycloneDX XML SBoM file.
    value: "${{ steps.ort-init.outputs.results-sbom-cyclonedx-xml-path }}"
  results-sbom-cyclonedx-json-path:
    description: Path to the CycloneDX JSON SBoM file.
    value: "${{ steps.ort-init.outputs.results-sbom-cyclonedx-json-path }}"
  results-sbom-spdx-json-path:
    description: Path to the SPDX JSON SBoM file.
    value: "${{ steps.ort-init.outputs.results-sbom-spdx-json-path }}"
  results-sbom-spdx-yml-path:
    description: Path to the SPDX YML SBoM file.
    value: "${{ steps.ort-init.outputs.results-sbom-spdx-yml-path }}"
  results-scanner-path:
    description: Path to the scanner result file.
    value: "${{ steps.ort-init.outputs.results-scanner-path }}"
  sw-name:
    description: The name of the software analyzed with ORT.
    value: "${{ steps.ort-init.outputs.sw-name }}"
  sw-name-safe:
    description: |
      The name of the software analyzed with ORT
      converted to contain only A-Z, a-z, 0-9 and hyphens.
    value: "${{ steps.ort-init.outputs.sw-name }}"
  sw-version:
    description: The version of the software analyzed with ORT.
    value: "${{ steps.ort-init.outputs.sw-version }}"

runs:
  using: "composite"
  steps:
    - name: Check if CI runner has packages installed needed by this action
      id: ort-ci-syschecks
      shell: bash
      env:
        ORT_RUN_MODE: ${{ inputs.mode }}
      run: |
        if [[ "$ORT_RUN_MODE" == "dnd" || "$ORT_RUN_MODE" == "docker-in-docker" ]]; then
          if ! command -v docker &> /dev/null; then
            echo -e "\e[1;31m ðŸ›‘ Failing action as Docker is not installed on the runner..."
            echo -e "\e[1;31m How to fix:"
            echo -e "\e[1;31mA) Use a runner image that supports docker-in-docker."
            echo -e "\e[1;31mB) Use this action with 'mode: da' to run it with the ORT distribution archive instead of a docker image."
            exit 2
          fi
        else
          if ! command -v hg &> /dev/null; then
            echo "is-hg-installed=false" >> $FORGEJO_OUTPUT
          else
            echo "is-hg-installed=true" >> $FORGEJO_OUTPUT
          fi

          if ! command -v java &> /dev/null; then
            echo "is-java-installed=false" >> $FORGEJO_OUTPUT
          else
            echo "is-java-installed=true" >> $FORGEJO_OUTPUT
          fi

          if ! command -v python &> /dev/null; then
            echo "is-python-installed=false" >> $FORGEJO_OUTPUT
          else
            echo "is-python-installed=true" >> $FORGEJO_OUTPUT
          fi
        fi

        if ! command -v git &> /dev/null; then
          echo "is-git-installed=false" >> $FORGEJO_OUTPUT
        else
          echo "is-git-installed=true" >> $FORGEJO_OUTPUT
        fi
    - name: Init Forgejo workspace
      id: ort-init
      if: ${{ contains(inputs.run, 'init') }}
      shell: bash
      env:
        ORT_CONFIG_PATH: ${{ inputs.ort-config-path }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        PROJECT_PATH: ${{ inputs.project-path }}
        SW_NAME: ${{ inputs.sw-name }}
        SW_VERSION: ${{ inputs.sw-version }}
        VCS_REVISION: ${{ inputs.vcs-revision }}
      run: |
        echo -e "\e[1;34m Initializing ORT in Forgejo workspace... "
        mkdir -p $HOME/.cache/scancode-tk/; chmod -R aug+w ${HOME}/.cache/ || :
        mkdir -p $HOME/.config/jgit/; chmod -R aug+w ${HOME}/.config/ || :
        mkdir -p $HOME/$ORT_HOME_PATH/{cache,config,ort-results,scanner/archive/,scanner/provenance/}; chmod -R aug+w ${HOME}/$ORT_HOME_PATH/ || :
        mkdir -p $HOME/.gradle/; chmod -R aug+w ${HOME}/.gradle/ || :
        mkdir -p $HOME/.rustup/{cache,download,tmp}; chmod -R aug+w ${HOME}/.rustup/ || :
        mkdir -p $HOME/go/; chmod -R aug+w ${HOME}/go/ || :
        ORT_CONFIG_PATH=${ORT_CONFIG_PATH:-"$HOME/$ORT_HOME_PATH/config"}
        ORT_RESULTS_PATH="$HOME/$ORT_HOME_PATH/ort-results"
        SW_NAME=${SW_NAME:-"unknown"}
        SW_VERSION=${SW_VERSION:-"unknown"}
        [[ -d "$PROJECT_PATH/.git" && "$SW_NAME" = "unknown" ]] && SW_NAME=$(cd $PROJECT_PATH; basename -s .git `git config --get remote.origin.url`)
        [[ "$SW_NAME" = "unknown" ]] && SW_NAME="${FORGEJO_REPOSITORY##*/}"
        [[ -d "$PROJECT_PATH/.git" && "$SW_VERSION" = "unknown" ]] && SW_VERSION=$(cd $PROJECT_PATH; git rev-parse --short HEAD)
        [[ "$SW_VERSION" = "unknown" ]] && SW_VERSION=${VCS_REVISION:-"${FORGEJO_SHA:0:8}"}
        # Remove all special characters and whitespace from software name as some tools cannot handle them.
        SW_NAME_SAFE=$(echo $SW_NAME | sed -e 's/[^A-Za-z0-9 \-\_]//g' -e 's/\s/-/g' -e 's/\([A-Z]\)/\L\1/g')
        ORT_RESULTS_ARTIFACT_NAME="ort-results-${SW_NAME_SAFE}"

        echo "ort-config-path=${ORT_CONFIG_PATH}" >> $FORGEJO_OUTPUT
        echo "results-advisor-path=${ORT_RESULTS_PATH}/advisor-result.json" >> $FORGEJO_OUTPUT
        echo "results-analyzer-path=${ORT_RESULTS_PATH}/analyzer-result.json" >> $FORGEJO_OUTPUT
        echo "results-artifact-name=${ORT_RESULTS_ARTIFACT_NAME}-${SW_VERSION}" >> $FORGEJO_OUTPUT
        echo "results-current-path=${ORT_RESULTS_PATH}/current-result.json" >> $FORGEJO_OUTPUT
        echo "results-evaluated-model-path=${ORT_RESULTS_PATH}/evaluated-model.json" >> $FORGEJO_OUTPUT
        echo "results-evaluator-path=${ORT_RESULTS_PATH}/evaluation-result.json" >> $FORGEJO_OUTPUT
        echo "results-path=${ORT_RESULTS_PATH}" >> $FORGEJO_OUTPUT
        echo "results-report-html-path=${ORT_RESULTS_PATH}/ort-results/scan-report.html" >> $FORGEJO_OUTPUT
        echo "results-report-web-app-path=${ORT_RESULTS_PATH}/ort-results/scan-report.html" >> $FORGEJO_OUTPUT
        echo "results-sbom-cyclonedx-json-path=${ORT_RESULTS_PATH}/bom.cyclonedx.json" >> $FORGEJO_OUTPUT
        echo "results-sbom-cyclonedx-xml-path=${ORT_RESULTS_PATH}/bom.cyclonedx.xml" >> $FORGEJO_OUTPUT
        echo "results-sbom-spdx-json-path=${ORT_RESULTS_PATH}/bom.spdx.json" >> $FORGEJO_OUTPUT
        echo "results-sbom-spdx-yml-path=${ORT_RESULTS_PATH}/bom.spdx.yml" >> $FORGEJO_OUTPUT
        echo "results-scanner-path=${ORT_RESULTS_PATH}/scan-result.json" >> $FORGEJO_OUTPUT
        echo "sw-name=${SW_NAME}" >> $FORGEJO_OUTPUT
        echo "sw-name-safe=${SW_NAME_SAFE}" >> $FORGEJO_OUTPUT
        echo "sw-version=${SW_VERSION}" >> $FORGEJO_OUTPUT

        if [[ -z "$(ls -A ${ORT_CONFIG_PATH})" ]]; then
          echo "is-ort-config-path-empty-dir=true" >> $FORGEJO_OUTPUT
        else
          echo "is-ort-config-path-empty-dir=false" >> $FORGEJO_OUTPUT
        fi
    - name: Set up Git if is not installed and the action will execute ORT scanner
      id: ort-da-install-git
      if: ${{ steps.ort-ci-syschecks.outputs.is-git-installed == 'false' && contains(inputs.run, 'scanner') && startsWith(runner.os, 'Linux') }}
      shell: bash
      run: |
        echo -e "\e[1;34m Git not found, installing..." && apt-get update && apt-get install -y git
        echo -e "\e[1;33m âš ï¸ Please install Git in your runner so it isn't installed each run ... "
    - name: Configure Git to download over HTTPS instead of SSH to avoid authentication issues
      id: config-git-use-https
      if: ${{ contains(inputs.run, 'config-git-use-https') && contains(inputs.run, 'scanner') && startsWith(runner.os, 'Linux') && (inputs.mode == 'da' || inputs.mode == 'dist-archive') }}
      run: git config --global url.https://github.com/.insteadOf ssh://git@github.com/
    - name: Set up Mercurial if is not installed and the action is run in dist archive mode
      id: ort-da-install-hg
      if: ${{
        steps.ort-ci-syschecks.outputs.is-hg-installed == 'false' &&
        (inputs.mode == 'da' || inputs.mode == 'dist-archive') &&
        startsWith(runner.os, 'Linux')
        }}
      shell: bash
      run: |
        echo -e "\e[1;34m Mercurial not found, installing... "
        echo -e "\e[1;33m âš ï¸ Please install Hg in your runner so it isn't installed each run ... "
        apt-get update
        apt-get install -y mercurial
    - name: Set up JDK21 if Java is not installed and action is run in dist archive mode
      id: ort-da-setup-java
      if: ${{
        steps.ort-ci-syschecks.outputs.is-java-installed == 'false' &&
        (inputs.mode == 'da' || inputs.mode == 'dist-archive')
        }}
      uses: actions/setup-java@v5
      with:
        distribution: "temurin"
        java-version: "21"
    - name: Set up ORT if mode is distribution archive (da)
      id: ort-da-setup-ort
      if: ${{ inputs.mode == 'da' || inputs.mode == 'dist-archive' }}
      shell: bash
      env:
        ORT_DIST_ARCHIVE_URL: ${{ inputs.inputs.dist-archive-url }}
        RUNNER_TOOL_CACHE: ${{ runner.tool_cache }}
      run: |
        if [[ -z "$ORT_DIST_ARCHIVE_URL" ]]; then
          # Find out the version number of latest ORT release
          response=$(curl -s "https://api.github.com/repos/oss-review-toolkit/ort/releases/latest")

          if [ $? -ne 0 ]; then
            echo -e "\e[1;33m âš ï¸ Unable to fetch the ORT latest release version, falling back to version ${{ env.ORT_VERSION_DEFAULT }}"
            ORT_VERSION=${{ env.ORT_VERSION_DEFAULT }}
          else
            ORT_VERSION=$(echo "$response" | grep -Po '"tag_name": "\K(.*)(?=")')
          fi
          ORT_DIST_ARCHIVE_URL="https://github.com/oss-review-toolkit/ort/releases/download/${ORT_VERSION}/ort-${ORT_VERSION}.tgz"
        fi

        RUNNER_TOOL_CACHE=${RUNNER_TOOL_CACHE:-"/opt/hostedtoolcache"}
        mkdir -p $RUNNER_TOOL_CACHE/ort
        echo -e "\e[1;34m Setting up ORT from release distribution archive in ${RUNNER_TOOL_CACHE}/ort... "
        echo -e "\e[1;34m Downloading ${ORT_DIST_ARCHIVE_URL}... "
        curl \
          -L $ORT_DIST_ARCHIVE_URL \
          -o - | tar -xzf - -C /opt/hostedtoolcache/ort --strip-components=1

        echo "PATH=$PATH:$RUNNER_TOOL_CACHE/ort/bin" >> "$FORGEJO_ENV"
        echo "dist-archive-url=${ORT_DIST_ARCHIVE_URL}" >> $FORGEJO_OUTPUT
        echo "ort-version=${ORT_VERSION}" >> $FORGEJO_OUTPUT
    - name: Set up ORT helper if mode is distribution archive (da)
      id: ort-da-setup-orth
      if: ${{
        contains(inputs.run, 'setup-orth') &&
        (inputs.mode == 'da' || inputs.mode == 'dist-archive')
        }}
      shell: bash
      env:
        ORTH_DIST_ARCHIVE_URL: ${{ inputs.inputs.orth-dist-archive-url }}
        RUNNER_TOOL_CACHE: ${{ runner.tool_cache }}
      run: |
        if [[ -z "$ORTH_DIST_ARCHIVE_URL" ]]; then
          # Find out the version number of latest ORT release
          response=$(curl -s "https://api.github.com/repos/oss-review-toolkit/ort/releases/latest")

          if [ $? -ne 0 ]; then
            echo -e "\e[1;33m âš ï¸ Unable to fetch the ORT helper latest release version, falling back to version ${{ env.ORT_VERSION_DEFAULT }}"
            ORT_VERSION=${{ env.ORT_VERSION_DEFAULT }}
          else
            ORT_VERSION=$(echo "$response" | grep -Po '"tag_name": "\K(.*)(?=")')
          fi
          ORTH_DIST_ARCHIVE_URL="https://github.com/oss-review-toolkit/ort/releases/download/${ORT_VERSION}/orth-${ORT_VERSION}.tgz"
        fi

        RUNNER_TOOL_CACHE=${RUNNER_TOOL_CACHE:-"/opt/hostedtoolcache"}
        mkdir -p $RUNNER_TOOL_CACHE/ort
        echo -e "\e[1;34m Setting up ORT helper from release distribution archive in ${RUNNER_TOOL_CACHE}/ort... "
        echo -e "\e[1;34m Downloading ${ORTH_DIST_ARCHIVE_URL}... "
        curl \
          -L $ORTH_DIST_ARCHIVE_URL \
          -o - | tar -xzf - -C /opt/hostedtoolcache/ort --strip-components=1

        echo "PATH=$PATH:$RUNNER_TOOL_CACHE/orth/bin" >> "$FORGEJO_ENV"
        echo "orth-dist-archive-url=${ORTH_DIST_ARCHIVE_URL}" >> $FORGEJO_OUTPUT
        echo "orth-version=${ORT_VERSION}" >> $FORGEJO_OUTPUT
    - name: Set up Python if not installed and action is run in dist archive mode
      id: ort-da-setup-python
      if: ${{
        steps.ort-ci-syschecks.outputs.is-python-installed == 'false' &&
        contains(inputs.run, 'setup-python') &&
        (inputs.mode == 'da' || inputs.mode == 'dist-archive')
        }}
      uses: actions/setup-python@v6
      with:
        python-version: "3.13"
    - name: Install setuptools via pip
      id: ort-da-setup-python-setuptools
      if: ${{
        contains(inputs.run, 'setup-python-setuptools') &&
        (inputs.mode == 'da' || inputs.mode == 'dist-archive')
        }}
      shell: bash
      run: |
        echo -e "\e[1;34m Python setuptools not found, installing... "
        echo -e "\e[1;33m âš ï¸ Please install setuptools in your runner so it isn't installed each run ... "
        pip install setuptools
    - name: Install python-inspector via pip, used by ORT for analyzing Python projects
      id: ort-da-setup-python-inspector
      if: ${{
        contains(inputs.run, 'setup-python-inspector') &&
        (inputs.mode == 'da' || inputs.mode == 'dist-archive')
        }}
      shell: bash
      run: |
        echo -e "\e[1;34m Python inspector not found, installing... "
        echo -e "\e[1;33m âš ï¸ Please install python-inspector in your runner so it isn't installed each run ... "
        pip install python-inspector
    - name: Shallow clone ort-config repository if ORT_CONFIG_PATH is empty
      id: ort-config-via-git
      if: ${{ steps.ort-ci-syschecks.outputs.is-git-installed == 'true' && steps.ort-init.outputs.is-ort-config-path-empty-dir == 'true' }}
      shell: bash
      env:
        ORT_CONFIG_PATH: ${{ steps.ort-init.outputs.ort-config-path }}
        ORT_CONFIG_VCS_URL: ${{ inputs.ort-config-repository }}
        ORT_CONFIG_VCS_REVISION: ${{ inputs.ort-config-revision }}
      run: |
        # Using bash instead of actions/checkout as we need to capture Git revision of ort-config
        ORT_CONFIG_VCS_REVISION=${ORT_CONFIG_VCS_REVISION:-$(git remote show origin | sed -n '/HEAD branch/s/.*: //p')}
        echo -e "\e[1;34m Retrieving ORT config from ${ORT_CONFIG_VCS_URL}... "
        cd $ORT_CONFIG_PATH
        git init -q
        git remote add origin $ORT_CONFIG_VCS_URL
        git fetch -q --depth 1 origin $ORT_CONFIG_VCS_REVISION
        git checkout -q FETCH_HEAD
        cd $ORT_CONFIG_PATH
        echo "ort-config-vcs-url=$(git config remote.origin.url)" >> $FORGEJO_OUTPUT
        echo "ort-config-vcs-revision=$(git rev-parse HEAD)" >> $FORGEJO_OUTPUT
        cd -
    - name: Retrieve ort-config repository archive if ORT_CONFIG_PATH dir is empty and Git is not installed
      id: ort-config-via-curl
      if: ${{ steps.ort-ci-syschecks.outputs.is-git-installed == 'false' && steps.ort-init.outputs.is-ort-config-path-empty-dir == 'true' }}
      shell: bash
      env:
        ORT_CONFIG_PATH: ${{ steps.ort-init.outputs.ort-config-path }}
        ORT_CONFIG_VCS_URL: ${{ inputs.ort-config-repository }}
      run: |
        if [[ -z "${ORT_CONFIG_VCS_URL}" ]]; then
            echo -e "\e[1;33m âš ï¸ Unable to use ${ORT_CONFIG_VCS_URL} as ort-config as Git is not installed."
        fi

        if command -v jar &> /dev/null; then
          # Retrieve ort-config using curl instead of action/checkout to avoid need for authentication
          echo -e "\e[1;34m Retrieving ORT config from ORT GitHub org using curl and jar... "
          echo -e "\e[1;33m Please install Git in your runner or CI run so revision of ORT config can be captured... "

          # Download the ort-config repository as a zip file
          curl -L -o ort-config.zip https://github.com/oss-review-toolkit/ort-config/archive/refs/heads/main.zip

          # Use jar to extract
          jar -xf ort-config.zip

          # Move the extracted files to the specified directory
          mv ort-config-main/* "$ORT_CONFIG_PATH"

          # Remove the empty directory created after extraction
          rm -rf ort-config-main

          # Delete the downloaded archive
          rm ort-config.zip
        else
          echo -e "\e[1;34m Retrieving only key ORT config from ${ORT_CONFIG_VCS_URL} using curl... "
          echo -e "\e[1;33m âš ï¸ Please install Git in your runner or CI run so ORT config revision can be captured ... "
          curl -sL -o $ORT_CONFIG_PATH/evaluator.rules.kts https://raw.githubusercontent.com/oss-review-toolkit/ort-config/main/evaluator.rules.kts
          curl -sL -o $ORT_CONFIG_PATH/license-classifications.yml https://raw.githubusercontent.com/oss-review-toolkit/ort-config/main/license-classifications.yml
          curl -sL -o $ORT_CONFIG_PATH/copyright-garbage.yml https://raw.githubusercontent.com/oss-review-toolkit/ort-config/main/copyright-garbage.yml
        fi

        echo "ort-config-vcs-url=https://github.com/oss-review-toolkit/ort-config.git" >> $FORGEJO_OUTPUT
        echo "ort-config-vcs-revision=main" >> $FORGEJO_OUTPUT
    - name: Compute ORT labels
      id: ort-labels
      if: contains(inputs.run, 'labels')
      shell: bash
      env:
        ORT_ALLOW_DYNAMIC_VERSIONS: ${{ inputs.allow-dynamic-versions }}
        ORT_CLI_ANALYZE_ARGS: ${{ inputs.ort-cli-analyze-args }}
        ORT_CLI_EVALUATE_ARGS: ${{ inputs.ort-cli-evaluate-args }}
        ORT_CLI_REPORT_ARGS: ${{ inputs.ort-cli-report-args }}
        ORT_DIST_ARCHIVE_URL: ${{ steps.ort-da-setup-ort.outputs.dist-archive-url || inputs.dist-archive-url }}
        ORT_CONFIG_VCS_URL: ${{ steps.ort-config-via-git.outputs.ort-config-vcs-url || steps.ort-config-via-curl.outputs.ort-config-vcs-url || inputs.ort-config-repository }}
        ORT_CONFIG_VCS_REVISION: ${{ steps.ort-config-via-git.outputs.ort-config-vcs-revision || steps.ort-config-via-curl.outputs.ort-config-vcs-revision || inputs.ort-config-revision }}
        ORT_DOCKER_IMAGE: ${{ inputs.image }}
        ORT_RUN_MODE: ${{ inputs.mode }}
        ORT_YML_PATH: ${{ inputs.ort-yml-path }}
        SW_NAME: ${{ steps.ort-init.outputs.sw-name }}
        SW_NAME_SAFE: ${{ steps.ort-init.outputs.sw-name-safe }}
        SW_VERSION: ${{ steps.ort-init.outputs.sw-version }}
      run: |
        echo -e "\e[1;34m Compute ORT labels... "
        export FORGEJO_RUN_URL="${FORGEJO_SERVER_URL}/${FORGEJO_REPOSITORY}/actions/runs/${FORGEJO_RUN_NUMBER}"

        ORT_CLI_ANALYZE_ARGS="\
          -l ci-url=${FORGEJO_RUN_URL} \
          -l ci-actor=${FORGEJO_ACTOR} \
          -l ci-event-name=${FORGEJO_EVENT_NAME} \
          -l ci-date=$(date +"%Y-%m-%d") \
          -l ci-timestamp=$(date -Iseconds) ${ORT_CLI_ANALYZE_ARGS}"

        [[ -n "${ORT_ALLOW_DYNAMIC_VERSIONS}" ]] && ORT_CLI_ANALYZE_ARGS="-l allow-dynamic-versions=${ORT_ALLOW_DYNAMIC_VERSIONS} ${ORT_CLI_ANALYZE_ARGS}"
        if [[ "$ORT_RUN_MODE" == "dnd" || "$ORT_RUN_MODE" == "docker-in-docker" ]] && ! command -v docker &> /dev/null; then
          [[ -n "${ORT_DOCKER_IMAGE}" ]] && ORT_CLI_ANALYZE_ARGS="-l ort-docker-image=${ORT_DOCKER_IMAGE} ${ORT_CLI_ANALYZE_ARGS}"
        fi
        if [[ "$ORT_RUN_MODE" == "da" || "$ORT_RUN_MODE" == "dist-archive" ]]; then
          [[ -n "${ORT_DIST_ARCHIVE_URL}" ]] && ORT_CLI_ANALYZE_ARGS="-l ort-dist-archive-url=${ORT_DIST_ARCHIVE_URL} ${ORT_CLI_ANALYZE_ARGS}"
        fi
        [[ -n "${ORT_CONFIG_VCS_REVISION}" ]] && ORT_CLI_ANALYZE_ARGS="-l ort-config-revision=${ORT_CONFIG_VCS_REVISION} ${ORT_CLI_ANALYZE_ARGS}"
        [[ -n "${ORT_CONFIG_VCS_URL}" ]] && ORT_CLI_ANALYZE_ARGS="-l ort-config-repository=${ORT_CONFIG_VCS_URL//oauth2*@/} ${ORT_CLI_ANALYZE_ARGS}"
        [[ ! "$SW_VERSION" = "unknown" ]] && ORT_CLI_ANALYZE_ARGS="-l sw-version=${SW_VERSION} ${ORT_CLI_ANALYZE_ARGS}"
        [[ ! "$SW_NAME" = "unknown" ]] && ORT_CLI_ANALYZE_ARGS="-l sw-name=${SW_NAME_SAFE} ${ORT_CLI_ANALYZE_ARGS}"

        if [[ -a "${ORT_YML_PATH}" ]]; then
          ORT_CLI_ANALYZE_ARGS="--repository-configuration-file ${ORT_YML_PATH} ${ORT_CLI_ANALYZE_ARGS}"
          ORT_CLI_EVALUATE_ARGS="--repository-configuration-file ${ORT_YML_PATH} ${ORT_CLI_EVALUATE_ARGS}"
          ORT_CLI_REPORT_ARGS="--repository-configuration-file ${ORT_YML_PATH} ${ORT_CLI_REPORT_ARGS}"

          echo "ort-cli-evaluate-args=${ORT_CLI_EVALUATE_ARGS}" >> $FORGEJO_OUTPUT
          echo "ort-cli-report-args=${ORT_CLI_REPORT_ARGS}" >> $FORGEJO_OUTPUT
        elif [ ! -f "${FORGEJO_WORKSPACE}/.ort.yml" ]; then
           echo -e "\e[1;31m No .ort.yml was found or set!"
        fi

        echo "ort-cli-analyze-args=${ORT_CLI_ANALYZE_ARGS}" >> $FORGEJO_OUTPUT
    - name: Cache dependencies
      id: cache-dependencies
      if: contains(inputs.run, 'cache-dependencies') && startsWith(runner.os, 'Linux')
      uses: actions/cache@v4
      env:
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
      with:
        path: |
          ~/.cabal/packages
          ~/.cabal/store
          ~/.cache/go-build
          ~/.cache/pip
          ~/.cache/yarn
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          ~/.composer
          ~/.gradle/caches
          ~/.gradle/wrapper
          ~/.ivy2/cache
          ~/.local/share/virtualenvs
          ~/.m2/repository
          ~/.npm
          ~/.nuget/packages
          !~/.nuget/packages/unwanted
          ~/.sbt
          ~/.stack-work
          ~/go/pkg/mod
          $HOME/$ORT_HOME_PATH/cache
        key: ${{ runner.os }}-ort-deps-cache
    - name: Cache ORT scan results
      id: cache-scan-results
      if: contains(inputs.run, 'cache-scan-results') && startsWith(runner.os, 'Linux')
      uses: actions/cache@v4
      with:
        path: "${{ env.HOME}}/${{ env.ORT_HOME_PATH }}/scanner/"
        key: ${{ runner.os }}-ort-scan-results-cache
    - name: Download project sources if vcs-url is set
      id: ort-da-download-project-sources
      if: ${{ inputs.vcs-url != '' && (inputs.mode == 'da' || inputs.mode == 'dist-archive') }}
      shell: bash
      env:
        ORT_CLI_DOWNLOAD_ARGS: ${{ inputs.ort-cli-download-args }}
        PROJECT_PATH: ${{ inputs.project-path }}
        PROJECT_VCS_PATH: ${{ inputs.vcs-path }}
        PROJECT_VCS_REVISION: ${{ inputs.vcs-revision }}
        PROJECT_VCS_TYPE: ${{ inputs.vcs-type }}
        PROJECT_VCS_URL: ${{ inputs.vcs-url }}
        SW_NAME_SAFE: ${{ steps.ort-init.outputs.sw-name-safe }}
      run: |
        echo -e "\e[1;34m Running ORT Downloader to download project to scan... "
        [[ -n "$PROJECT_VCS_TYPE" ]] && ORT_CLI_DOWNLOAD_ARGS="--vcs-type ${PROJECT_VCS_TYPE} ${ORT_CLI_DOWNLOAD_ARGS}"
        [[ -n "$PROJECT_VCS_URL" ]] && ORT_CLI_DOWNLOAD_ARGS="--project-url ${PROJECT_VCS_URL} ${ORT_CLI_DOWNLOAD_ARGS}"
        [[ -n "$PROJECT_VCS_REVISION" ]] && ORT_CLI_DOWNLOAD_ARGS="--vcs-revision ${PROJECT_VCS_REVISION} ${ORT_CLI_DOWNLOAD_ARGS}"
        [[ -n "$PROJECT_VCS_PATH" ]] && ORT_CLI_DOWNLOAD_ARGS="--vcs-path ${PROJECT_VCS_PATH} ${ORT_CLI_DOWNLOAD_ARGS}"
        [[ -n "$SW_NAME_SAFE" ]] && ORT_CLI_DOWNLOAD_ARGS="--project-name ${SW_NAME_SAFE} ${ORT_CLI_DOWNLOAD_ARGS}"
        ort
        --${{ inputs.log-level }} \
        ${{ inputs.ort-cli-args }} \
        download \
        -o ${PROJECT_PATH} \
        ${ORT_CLI_DOWNLOAD_ARGS}
    - name: Download project sources using docker if vcs-url is set
      id: ort-dnd-download-project-sources
      if: ${{ inputs.vcs-url != '' && (inputs.mode == 'dnd' || inputs.mode == 'docker-in-docker') }}
      shell: bash
      env:
        ORT_CLI_DOWNLOAD_ARGS: ${{ inputs.ort-cli-download-args }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        PROJECT_PATH: ${{ inputs.project-path }}
        PROJECT_VCS_PATH: ${{ inputs.vcs-path }}
        PROJECT_VCS_REVISION: ${{ inputs.vcs-revision }}
        PROJECT_VCS_TYPE: ${{ inputs.vcs-type }}
        PROJECT_VCS_URL: ${{ inputs.vcs-url }}
        SW_NAME_SAFE: ${{ steps.ort-init.outputs.sw-name-safe }}
      run: |
        echo -e "\e[1;34m Running ORT Downloader using docker to download project to scan... "
        [[ -n "$PROJECT_VCS_TYPE" ]] && ORT_CLI_DOWNLOAD_ARGS="--vcs-type ${PROJECT_VCS_TYPE} ${ORT_CLI_DOWNLOAD_ARGS}"
        [[ -n "$PROJECT_VCS_URL" ]] && ORT_CLI_DOWNLOAD_ARGS="--project-url ${PROJECT_VCS_URL} ${ORT_CLI_DOWNLOAD_ARGS}"
        [[ -n "$PROJECT_VCS_REVISION" ]] && ORT_CLI_DOWNLOAD_ARGS="--vcs-revision ${PROJECT_VCS_REVISION} ${ORT_CLI_DOWNLOAD_ARGS}"
        [[ -n "$PROJECT_VCS_PATH" ]] && ORT_CLI_DOWNLOAD_ARGS="--vcs-path ${PROJECT_VCS_PATH} ${ORT_CLI_DOWNLOAD_ARGS}"
        [[ -n "$SW_NAME_SAFE" ]] && ORT_CLI_DOWNLOAD_ARGS="--project-name ${SW_NAME_SAFE} ${ORT_CLI_DOWNLOAD_ARGS}"
        docker run \
        --mount type=bind,source=$HOME,target=/home/ort \
        -u $(id -u):$(id -g) \
        -e JDK_JAVA_OPTIONS="-Xmx5120m" \
        -e ORT_DATA_DIR="/home/ort/${ORT_HOME_PATH}" \
        ${{ inputs.docker-cli-args }} \
        ${{ inputs.image }} \
        --${{ inputs.log-level }} \
        ${{ inputs.ort-cli-args }} \
        download \
        -o ${PROJECT_PATH/${FORGEJO_ACTOR}/ort} \
        ${ORT_CLI_DOWNLOAD_ARGS}
    - name: Run ORT Analyzer
      id: ort-da-analyzer
      if: ${{ contains(inputs.run, 'analyzer') && (inputs.mode == 'da' || inputs.mode == 'dist-archive') }}
      shell: bash
      env:
        ORT_ALLOW_DYNAMIC_VERSIONS: ${{ inputs.allow-dynamic-versions }}
        ORT_CLI_ANALYZE_ARGS: ${{ steps.ort-labels.outputs.ort-cli-analyze-args || inputs.ort-cli-analyze-args }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        ORT_RESULTS_ANALYZER_PATH: ${{ steps.ort-init.outputs.results-analyzer-path }}
        ORT_RESULTS_CURRENT_PATH: ${{ steps.ort-init.outputs.results-current-path }}
        ORT_RESULTS_PATH: ${{ steps.ort-init.outputs.results-path }}
        PROJECT_PATH: ${{ inputs.project-path }}
        SW_NAME_SAFE: ${{ steps.ort-init.outputs.sw-name-safe }}
      run: |
        echo -e "\e[1;34m Running ORT Analyzer... "
        ort \
        --${{ inputs.log-level }} \
        -P ort.analyzer.allowDynamicVersions=${ORT_ALLOW_DYNAMIC_VERSIONS} \
        ${{ inputs.ort-cli-args }} \
        analyze \
        -i $PROJECT_PATH \
        -o $ORT_RESULTS_PATH \
        -f JSON \
        ${ORT_CLI_ANALYZE_ARGS} || ORT_CLI_ANALYZE_EXIT_CODE=$? \
        && ORT_CLI_ANALYZE_EXIT_CODE="${ORT_CLI_ANALYZE_EXIT_CODE:-0}" \
        && echo "ORT_CLI_ANALYZE_EXIT_CODE=${ORT_CLI_ANALYZE_EXIT_CODE}" >> "$FORGEJO_ENV"
        [[ -f $ORT_RESULTS_ANALYZER_PATH ]] && \
          ln -frs $ORT_RESULTS_ANALYZER_PATH $ORT_RESULTS_CURRENT_PATH || \
          echo -e "\e[1;31m File $ORT_RESULTS_ANALYZER_PATH not found."
        [[ $ORT_CLI_ANALYZE_EXIT_CODE -ne 2 ]] && exit ${ORT_CLI_ANALYZE_EXIT_CODE} || exit 0
    - name: Run ORT Analyzer using docker
      id: ort-dnd-analyzer
      if: ${{ contains(inputs.run, 'analyzer') && (inputs.mode == 'dnd' || inputs.mode == 'docker-in-docker') }}
      shell: bash
      env:
        ORT_ALLOW_DYNAMIC_VERSIONS: ${{ inputs.allow-dynamic-versions }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        ORT_RESULTS_ANALYZER_PATH: ${{ steps.ort-init.outputs.results-analyzer-path }}
        ORT_RESULTS_CURRENT_PATH: ${{ steps.ort-init.outputs.results-current-path }}
        ORT_RESULTS_PATH: ${{ steps.ort-init.outputs.results-path }}
        PROJECT_PATH: ${{ inputs.project-path }}
        SW_NAME_SAFE: ${{ steps.ort-init.outputs.sw-name-safe }}
      run: |
        echo -e "\e[1;34m Running ORT Analyzer using docker... "
        docker run \
        --mount type=bind,src=$HOME,dst=/home/ort \
        --mount type=bind,src=$PROJECT_PATH,dst=/workspace/$SW_NAME_SAFE \
        -u $(id -u):$(id -g) \
        -e JDK_JAVA_OPTIONS="-Xmx5120m" \
        -e ORT_DATA_DIR="/home/ort/${ORT_HOME_PATH}" \
        ${{ inputs.docker-cli-args }} \
        ${{ inputs.image }} \
        --${{ inputs.log-level }} \
        -P ort.analyzer.allowDynamicVersions=${ORT_ALLOW_DYNAMIC_VERSIONS} \
        ${{ inputs.ort-cli-args }} \
        analyze \
        -i /workspace/SW_NAME_SAFE \
        -o ${ORT_RESULTS_PATH/$USER/ort} \
        -f JSON \
        ${ORT_CLI_ANALYZE_ARGS} || ORT_CLI_ANALYZE_EXIT_CODE=$? \
        && ORT_CLI_ANALYZE_EXIT_CODE="${ORT_CLI_ANALYZE_EXIT_CODE:-0}" \
        && echo "ORT_CLI_ANALYZE_EXIT_CODE=${ORT_CLI_ANALYZE_EXIT_CODE}" >> "$FORGEJO_ENV"
        [[ -f $ORT_RESULTS_ANALYZER_PATH ]] && \
          ln -frs $ORT_RESULTS_ANALYZER_PATH $ORT_RESULTS_CURRENT_PATH || \
          echo -e "\e[1;31m File $ORT_RESULTS_ANALYZER_PATH not found."
        [[ $ORT_CLI_ANALYZE_EXIT_CODE -ne 2 ]] && exit ${ORT_CLI_ANALYZE_EXIT_CODE} || exit 0
    - name: Run ORT Scanner
      id: ort-da-scanner
      if: ${{ contains(inputs.run, 'scanner') && (inputs.mode == 'da' || inputs.mode == 'dist-archive') }}
      shell: bash
      env:
        ORT_CLI_SCAN_ARGS: ${{ inputs.ort-cli-scan-args }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        ORT_RESULTS_CURRENT_PATH: ${{ steps.ort-init.outputs.results-current-path }}
        ORT_RESULTS_HOME_PATH: ${{ steps.ort-init.outputs.results-home-path }}
        ORT_RESULTS_PATH: ${{ steps.ort-init.outputs.results-path }}
        ORT_RESULTS_SCANNER_PATH: ${{ steps.ort-init.outputs.results-scanner-path }}
      run: |
        echo -e "\e[1;34m Running ORT Scanner... "
        eval "$(ssh-agent -s)"
        ort \
        --${{ inputs.log-level }} \
        ${{ inputs.ort-cli-args }} \
        scan \
        -i $ORT_RESULTS_CURRENT_PATH \
        -o $ORT_RESULTS_PATH \
        -f JSON \
        ${ORT_CLI_SCAN_ARGS}
        [[ -f $ORT_RESULTS_SCANNER_PATH ]] && \
          ln -frs $ORT_RESULTS_SCANNER_PATH $ORT_RESULTS_CURRENT_PATH || \
          echo -e "\e[1;31m File $ORT_RESULTS_SCANNER_PATH not found."
    - name: Run ORT Scanner using docker
      id: ort-dnd-scanner
      if: ${{ contains(inputs.run, 'scanner') && (inputs.mode == 'dnd' || inputs.mode == 'docker-in-docker') }}
      shell: bash
      env:
        ORT_CLI_SCAN_ARGS: ${{ inputs.ort-cli-scan-args }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        ORT_RESULTS_CURRENT_PATH: ${{ steps.ort-init.outputs.results-current-path }}
        ORT_RESULTS_HOME_PATH: ${{ steps.ort-init.outputs.results-home-path }}
        ORT_RESULTS_PATH: ${{ steps.ort-init.outputs.results-path }}
        ORT_RESULTS_SCANNER_PATH: ${{ steps.ort-init.outputs.results-scanner-path }}
      run: |
        echo -e "\e[1;34m Running ORT Scanner using docker... "
        eval "$(ssh-agent -s)"
        docker run \
        --mount type=bind,source=$HOME,target=/home/ort \
        --mount type=tmpfs,target=/tmp \
        -v ${SSH_AUTH_SOCK}:/ssh.socket \
        -e JDK_JAVA_OPTIONS="-Xmx5120m" \
        -e ORT_DATA_DIR="/home/ort/${ORT_HOME_PATH}" \
        -e HTTP_FILE_SERVER_PASSWORD="${{ inputs.http-file-server-password }}" \
        -e HTTP_FILE_SERVER_TOKEN="${{ inputs.http-file-server-token }}" \
        -e HTTP_FILE_SERVER_URL="${{ inputs.http-file-server-url }}" \
        -e HTTP_FILE_SERVER_USERNAME="${{ inputs.http-file-server-username }}" \
        -e POSTGRES_URL="${{ inputs.db-url }}" \
        -e POSTGRES_USERNAME="${{ inputs.db-username }}" \
        -e POSTGRES_PASSWORD="${{ inputs.db-password }}" \
        -e SSH_AUTH_SOCK="${SSH_AUTH_SOCK}" \
        -e XDG_CONFIG_HOME="/home/ort/.config/" \
        -u $(id -u):$(id -g) \
        ${{ inputs.docker-cli-args }} \
        ${{ inputs.image }} \
        --${{ inputs.log-level }} \
        ${{ inputs.ort-cli-args }} \
        scan \
        -i ${ORT_RESULTS_CURRENT_PATH/${FORGEJO_ACTOR}/ort} \
        -o ${ORT_RESULTS_PATH/${FORGEJO_ACTOR}/ort} \
        -f JSON \
        ${ORT_CLI_SCAN_ARGS}
        [[ -f $ORT_RESULTS_SCANNER_PATH ]] && \
          ln -frs $ORT_RESULTS_SCANNER_PATH $ORT_RESULTS_CURRENT_PATH || \
          echo -e "\e[1;31m File $ORT_RESULTS_SCANNER_PATH not found."
    - name: Run ORT Advisor
      id: ort-da-advisor
      if: ${{ contains(inputs.run, 'advisor') && (inputs.mode == 'da' || inputs.mode == 'dist-archive') }}
      shell: bash
      env:
        ORT_ADVISORS: ${{ inputs.advisors }}
        ORT_CLI_ADVISE_ARGS: ${{ inputs.ort-cli-advise-args }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        ORT_RESULTS_ADVISOR_PATH: ${{ steps.ort-init.outputs.results-advisor-path }}
        ORT_RESULTS_CURRENT_PATH: ${{ steps.ort-init.outputs.results-current-path }}
        ORT_RESULTS_PATH: ${{ steps.ort-init.outputs.results-path }}
      run: |
        echo -e "\e[1;34m Running ORT Advisor... "
        ort \
        --${{ inputs.log-level }} \
        ${{ inputs.ort-cli-args }} \
        advise \
        -i $ORT_RESULTS_CURRENT_PATH \
        -o $ORT_RESULTS_PATH \
        -a $ORT_ADVISORS \
        -f JSON \
        ${ORT_CLI_ADVISE_ARGS} || ORT_CLI_ADVISE_EXIT_CODE=$? \
        && ORT_CLI_ADVISE_EXIT_CODE="${ORT_CLI_ADVISE_EXIT_CODE:-0}" \
        && echo "exit-code=${ORT_CLI_EVALUATE_EXIT_CODE}" >> "$FORGEJO_OUTPUT"
        [[ -f $ORT_RESULTS_ADVISOR_PATH ]] && \
          ln -frs $ORT_RESULTS_ADVISOR_PATH $ORT_RESULTS_CURRENT_PATH || \
          echo -e "\e[1;31m File $ORT_RESULTS_ADVISOR_PATH not found."
        [[ $ORT_CLI_ADVISE_EXIT_CODE -ne 2 ]] && exit ${ORT_CLI_ADVISE_EXIT_CODE} || exit 0
    - name: Run ORT Advisor using docker
      id: ort-dnd-advisor
      if: ${{ contains(inputs.run, 'advisor') && (inputs.mode == 'dnd' || inputs.mode == 'docker-in-docker') }}
      shell: bash
      env:
        ORT_ADVISORS: ${{ inputs.advisors }}
        ORT_CLI_ADVISE_ARGS: ${{ inputs.ort-cli-advise-args }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        ORT_RESULTS_ADVISOR_PATH: ${{ steps.ort-init.outputs.results-advisor-path }}
        ORT_RESULTS_CURRENT_PATH: ${{ steps.ort-init.outputs.results-current-path }}
        ORT_RESULTS_PATH: ${{ steps.ort-init.outputs.results-path }}
      run: |
        echo -e "\e[1;34m Running ORT Advisor using docker... "
        docker run \
        --mount type=bind,source=$HOME,target=/home/ort \
        -e JDK_JAVA_OPTIONS="-Xmx5120m" \
        -e ORT_DATA_DIR="/home/ort/${ORT_HOME_PATH}" \
        -u $(id -u):$(id -g) \
        ${{ inputs.docker-cli-args }} \
        ${{ inputs.image }} \
        --${{ inputs.log-level }} \
        ${{ inputs.ort-cli-args }} \
        advise \
        -i ${ORT_RESULTS_CURRENT_PATH/${FORGEJO_ACTOR}/ort} \
        -o ${ORT_RESULTS_PATH/${FORGEJO_ACTOR}/ort} \
        -a $ORT_ADVISORS \
        -f JSON \
        ${ORT_CLI_ADVISE_ARGS} || ORT_CLI_ADVISE_EXIT_CODE=$? \
        && ORT_CLI_ADVISE_EXIT_CODE="${ORT_CLI_ADVISE_EXIT_CODE:-0}" \
        && echo "exit-code=${ORT_CLI_EVALUATE_EXIT_CODE}" >> "$FORGEJO_OUTPUT"
        [[ -f $ORT_RESULTS_ADVISOR_PATH ]] && \
          ln -frs $ORT_RESULTS_ADVISOR_PATH $ORT_RESULTS_CURRENT_PATH || \
          echo -e "\e[1;31m File $ORT_RESULTS_ADVISOR_PATH not found."
        [[ $ORT_CLI_ADVISE_EXIT_CODE -ne 2 ]] && exit ${ORT_CLI_ADVISE_EXIT_CODE} || exit 0
    - name: Run ORT Evaluator
      id: ort-da-evaluator
      if: ${{ contains(inputs.run, 'evaluator') && (inputs.mode == 'da' || inputs.mode == 'dist-archive') }}
      shell: bash
      env:
        ORT_CLI_EVALUATE_ARGS: ${{ steps.ort-labels.outputs.ort-cli-evaluate-args || inputs.ort-cli-evaluate-args }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        ORT_RESULTS_CURRENT_PATH: ${{ steps.ort-init.outputs.results-current-path }}
        ORT_RESULTS_EVALUATOR_PATH: ${{ steps.ort-init.outputs.results-evaluator-path }}
        ORT_RESULTS_PATH: ${{ steps.ort-init.outputs.results-path }}
      run: |
        echo -e "\e[1;34m Running ORT Evaluator... "
        ort \
        --${{ inputs.log-level }} \
        ${{ inputs.ort-cli-args }} \
        evaluate \
        -i ${ORT_RESULTS_CURRENT_PATH/${FORGEJO_ACTOR}/ort} \
        -o ${ORT_RESULTS_PATH/${FORGEJO_ACTOR}/ort} \
        -f JSON \
        ${ORT_CLI_EVALUATE_ARGS} || ORT_CLI_EVALUATE_EXIT_CODE=$? \
        && ORT_CLI_EVALUATE_EXIT_CODE="${ORT_CLI_EVALUATE_EXIT_CODE:-0}" \
        && echo "exit-code=${ORT_CLI_EVALUATE_EXIT_CODE}" >> "$FORGEJO_OUTPUT"
        [[ -f $ORT_RESULTS_EVALUATOR_PATH ]] && \
          ln -frs $ORT_RESULTS_EVALUATOR_PATH $ORT_RESULTS_CURRENT_PATH || \
          echo -e "\e[1;31m File $ORT_RESULTS_EVALUATOR_PATH not found."
        [[ $ORT_CLI_EVALUATE_EXIT_CODE -ne 2 ]] && exit ${ORT_CLI_EVALUATE_EXIT_CODE} || exit 0
    - name: Run ORT Evaluator using docker
      id: ort-dnd-evaluator
      if: ${{ contains(inputs.run, 'evaluator') && (inputs.mode == 'dnd' || inputs.mode == 'docker-in-docker') }}
      shell: bash
      env:
        ORT_CLI_EVALUATE_ARGS: ${{ steps.ort-labels.outputs.ort-cli-evaluate-args || inputs.ort-cli-evaluate-args }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        ORT_RESULTS_CURRENT_PATH: ${{ steps.ort-init.outputs.results-current-path }}
        ORT_RESULTS_EVALUATOR_PATH: ${{ steps.ort-init.outputs.results-evaluator-path }}
        ORT_RESULTS_PATH: ${{ steps.ort-init.outputs.results-path }}
      run: |
        echo -e "\e[1;34m Running ORT Evaluator using docker... "
        docker run \
        --mount type=bind,source=$HOME,target=/home/ort \
        -e JDK_JAVA_OPTIONS="-Xmx5120m" \
        -e ORT_DATA_DIR="/home/ort/${ORT_HOME_PATH}" \
        -u $(id -u):$(id -g) \
        ${{ inputs.docker-cli-args }} \
        ${{ inputs.image }} \
        --${{ inputs.log-level }} \
        ${{ inputs.ort-cli-args }} \
        evaluate \
        -i ${ORT_RESULTS_CURRENT_PATH/${FORGEJO_ACTOR}/ort} \
        -o ${ORT_RESULTS_PATH/${FORGEJO_ACTOR}/ort} \
        -f JSON \
        ${ORT_CLI_EVALUATE_ARGS} || ORT_CLI_EVALUATE_EXIT_CODE=$? \
        && ORT_CLI_EVALUATE_EXIT_CODE="${ORT_CLI_EVALUATE_EXIT_CODE:-0}" \
        && echo "exit-code=${ORT_CLI_EVALUATE_EXIT_CODE}" >> "$FORGEJO_OUTPUT"
        [[ -f $ORT_RESULTS_EVALUATOR_PATH ]] && \
          ln -frs $ORT_RESULTS_EVALUATOR_PATH $ORT_RESULTS_CURRENT_PATH || \
          echo -e "\e[1;31m File $ORT_RESULTS_EVALUATOR_PATH not found."
        [[ $ORT_CLI_EVALUATE_EXIT_CODE -ne 2 ]] && exit ${ORT_CLI_EVALUATE_EXIT_CODE} || exit 0
    - name: Run ORT Reporter
      id: ort-da-reporter
      if: ${{ contains(inputs.run, 'reporter') && (inputs.mode == 'da' || inputs.mode == 'dist-archive') }}
      shell: bash
      env:
        ORT_CLI_REPORT_ARGS: ${{ steps.ort-labels.outputs.ort-cli-report-args || inputs.ort-cli-report-args }}
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        ORT_REPORT_FORMATS: ${{ inputs.report-formats }}
        ORT_RESULTS_CURRENT_PATH: ${{ steps.ort-init.outputs.results-current-path }}
        ORT_RESULTS_PATH: ${{ steps.ort-init.outputs.results-path }}
      run: |
        echo -e "\e[1;34m Running ORT Reporter... "
        ort \
        --${{ inputs.log-level }} \
        ${{ inputs.ort-cli-args }} \
        report \
        -i $ORT_RESULTS_CURRENT_PATH \
        -o $ORT_RESULTS_PATH \
        -f $ORT_REPORT_FORMATS \
        -O SpdxDocument=document.name="${{ steps.ort-init.outputs.sw-name-safe }}" \
        ${ORT_CLI_REPORT_ARGS}
    - name: Run ORT Reporter using Docker
      id: ort-dnd-reporter
      if: ${{ contains(inputs.run, 'reporter') && (inputs.mode == 'dnd' || inputs.mode == 'docker-in-docker') }}
      shell: bash
      env:
        ORT_CLI_REPORT_ARGS: steps.ort-labels.outputs.ort-cli-report-args || inputs.ort-cli-report-args
        ORT_HOME_PATH: ${{ inputs.ort-home-path }}
        ORT_REPORT_FORMATS: ${{ inputs.report-formats }}
        ORT_RESULTS_CURRENT_PATH: ${{ steps.ort-init.outputs.results-current-path }}
        ORT_RESULTS_PATH: ${{ steps.ort-init.outputs.results-path }}
      run: |
        echo -e "\e[1;34m Running ORT Reporter... "
        docker run \
        --mount type=bind,source=$HOME,target=/home/ort \
        -e JDK_JAVA_OPTIONS="-Xmx5120m" \
        -e ORT_DATA_DIR="/home/ort/${ORT_HOME_PATH}" \
        -e POSTGRES_URL="${{ inputs.db-url }}" \
        -e POSTGRES_USERNAME="${{ inputs.db-username }}" \
        -e POSTGRES_PASSWORD="${{ inputs.db-password }}" \
        -u $(id -u):$(id -g) \
        ${{ inputs.docker-cli-args }} \
        ${{ inputs.image }} \
        --${{ inputs.log-level }} \
        ${{ inputs.ort-cli-args }} \
        report \
        -i ${ORT_RESULTS_CURRENT_PATH/${FORGEJO_ACTOR}/ort} \
        -o ${ORT_RESULTS_PATH/${FORGEJO_ACTOR}/ort} \
        -f $ORT_REPORT_FORMATS \
        -O SpdxDocument=document.name="${{ steps.ort-init.outputs.sw-name-safe }}" \
        ${ORT_CLI_REPORT_ARGS}
    - name: Remove current-result.yml file if present
      shell: bash
      run: |
        if [[ -f "${{ steps.ort-init.outputs.results-current-path }}" ]]; then
            rm -f ${{ steps.ort-init.outputs.results-current-path }}
        fi
    - name: Upload ORT results
      if: contains(inputs.run, 'upload-results')
      uses: https://data.forgejo.org/forgejo/upload-artifact@v4
      with:
        name: ${{ steps.ort-init.outputs.results-artifact-name }}
        path: ${{ steps.ort-init.outputs.results-path }}
        if-no-files-found: warn
    - name: Upload ORT advisor-result.json
      if: contains(inputs.run, 'upload-advisor-result')
      uses: https://data.forgejo.org/forgejo/upload-artifact@v4
      with:
        name: "${{ steps.ort-init.outputs.results-artifact-name }}-advisor-result.json.zip"
        path: ${{ steps.ort-init.outputs.results-advisor-path }}
        if-no-files-found: warn
    - name: Upload ORT evaluation-result.json
      if: contains(inputs.run, 'upload-evaluation-result')
      uses: actions/upload-artifact@v4
      with:
        name: "${{ steps.ort-init.outputs.results-artifact-name }}-evaluation-result.json.zip"
        path: ${{ steps.ort-init.outputs.results-evaluator-path }}
        if-no-files-found: warn
    - name: Upload ORT scan-result.json
      if: contains(inputs.run, 'upload-scan-result')
      uses: actions/upload-artifact@v4
      with:
        name: "${{ steps.ort-init.outputs.results-artifact-name }}-scan-result.json.zip"
        path: ${{ steps.ort-init.outputs.results-scanner-path }}
        if-no-files-found: warn
    - name: Conditionally fail action if returned violations from Evaluator exceeds severity threshold
      if: contains(inputs.fail-on, 'violations') && contains(steps.ort-evaluator.outputs.exit-code, 2)
      shell: bash
      run: |
        echo -e "\e[1;31m ðŸ›‘ Failing action as Evaluator exceeded severity threshold... "
        exit 2
    - name: Conditionally fail action if returned issues from Advisor exceeds severity threshold
      if: contains(inputs.fail-on, 'issues') && contains(steps.ort-advisor.outputs.exit-code, 2)
      shell: bash
      run: |
        echo -e "\e[1;31m ðŸ›‘ Failing action as Advisor exceeded severity threshold... "
        exit 2
